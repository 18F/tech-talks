Functional Programming in Python
================================

+   18F Logo.

+   Intro self.
+   Blank image.
+   Pure functions, immutability, recursion.
+   Pure functions.

    Purity: no loading from files, no database check, no global variables.
    No side effects: print to the console, launch satellites, start your neighbor's car.

    XKCD image.

    Blank image.
    
    Python no enforcement, but ``load_`` and ``write_``.
+   Immutability.

    Strings and tuples are immutable.

    Dicts and lists are mutable.

    Set mutable but there's frozenset.

    See also: named tuples and dataclasses with frozen=True.

    If things are immutable, how do we do things?

    Parmenides image.

    We don't, because change is an illusion and thus doing things is impossible.

    We mostly create new things and discard the old ones. If you're changing a list, create a new list,
    same with dictionaries. Comprehensions support this. Be careful when dealing with extremely large lists,
    but that's not typically the case.

    Blank image.

    Not mutating things helps us reason about code more easily.
+   Recursion.
+   FP benefit: breaking problems into a series of small steps, each of which is ideally simple.

    If almost all the steps themselves are pure functions, we get easy testing and easier reasoning.

    Also, this mode of thinking has helped me see better ways to solve problems.
+   This approach lends itself to applying simple functions to streams of data.
    Classic FP ways of doing this are present, but so are idiomatic Python ways that you should consider.

    ``map`` versus list comprehension/generator comprehension.

    ``filter`` versus comprehension.
    Note that comprehension doesn't require creating a lambda for comparison.

+   Having to turn code into small steps makes repetition obvious. (And easy to fix.)

    Not just in files or projects, but across projects.

    I have a bunch of functions I've noticed I frequently use:

    +   ``splitstriplines``
    +   ``pick`` / ``omit``
    +   ``oxford``

+   Series of variables.
    
+   ``reduce``.

+   ``operator.methodcaller``

    ``operator`` also has a lot of other functions that make FP easier to write.
+   ``itertools`` is also very handy for manipulating streams, especially:

    +   ``chain.from_iterable``
    +   ``groupby``
    +   ``starmap``
+   ``toolz`` (and ``cytoolz``).

    +   ``compose`` / ``compose_left``
    +   ``pipe``
    +   ``sliding_window``
